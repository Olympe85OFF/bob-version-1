<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Bob 1- Version 0.1</title>
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="manifest" href="/site.webmanifest" />
    <meta name="msapplication-TileColor" content="#da532c" />
    <meta name="theme-color" content="#29adff" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.80.1/phaser.min.js"></script>
    <style>
      body {
        margin: 0;
        background-color: #29adff;
      }
    </style>
  </head>
  <body>
    <script>
      // Globales
      const PLAYER_VELOCITY = 240
      const PLAYER_BOUNCE_OFF_VELOCITY = 400
      const PLAYER_MIN_JUMP_VELOCITY = -360
      const PLAYER_MAX_JUMP_VELOCITY = -400
      const PLAYER_FLAPPY_VELOCITY = -520
      const PLAYER_MAX_JUMP_TIME = 150
      const PLAYER_BUFFERING_TIME = 200
      const PLAYER_COYOTE_TIME = 200
      const PLAYER_MAX_JUMPS = 2
      const PLAYER_DEATH_JUMP_X = 100
      const PLAYER_DEATH_JUMP_Y = -600
      const PLAYER_FALL_SQUASH_VELOCITY = 700
      const ENEMY_VELOCITY = 140
      const ENEMY2_JUMP_DELAY = 2000
      const NUM_LEVELS = 1
      const SPIKY_BALL_SPEED = 200
      const TILE_SIZE = 40
      const COIN_SIZE = 30
      const CANNON_FIRE_RATE = 1400
      const FIREBALL_VELOCITY = 360
      const PLAYER_MODE_PLATFORM = 'platform'
      const PLAYER_MODE_FLAPPY = 'flappy'
      const ANALYTICS_ENEMY_KILLED = 'enemy:killed'
      const ANALYTICS_PLAYER_DEATH = 'player:death'
      const ANALYTICS_COIN_COLLECTED = 'coin:collected'

      // Niveaux
      const levelsData = {
        level1: {
            world: { width: 2920, height: 540 },
            player: { x: 0, y: 480 },
            
            target: { x: 2800, y: 200 },
            platforms: [
              { x: 880, y: 240, width: 40, height: 40 },
              { x: 1440, y: 240, width: 40, height: 40 },
              { x: 880, y: 280, width: 40, height: 40 },
              { x: 1440, y: 280, width: 40, height: 40 },
              { x: 880, y: 320, width: 40, height: 40 },
              { x: 1440, y: 320, width: 40, height: 40 },
              { x: 840, y: 360, width: 640, height: 40 },
              { x: 840, y: 400, width: 640, height: 40 },
              { x: 680, y: 440, width: 120, height: 40 },
              { x: 840, y: 440, width: 640, height: 40 },
              { x: 840, y: 480, width: 640, height: 40 },
              { x: 0, y: 520, width: 1480, height: 40 }
            ],
            cannons: [
              { x: 1400, y: 240, dir: 2 },
              { x: 920, y: 280, dir: 2 },
              { x: 1400, y: 320, dir: 2 }
            ],
            oneWayPlatforms: [
              { x: 2440, y: 400, width: 40 },
              { x: 2480, y: 400, width: 40 },
              { x: 2520, y: 400, width: 40 },
              { x: 2560, y: 400, width: 40 }
            ],
            fallingBlocks: [
              { x: 1680, y: 200 },
              { x: 1560, y: 240 },
              { x: 1800, y: 240 },
              { x: 2200, y: 240 },
              { x: 2240, y: 240 },
              { x: 2120, y: 320 },
              { x: 2760, y: 320 },
              { x: 2800, y: 320 },
              { x: 2840, y: 320 },
              { x: 1920, y: 360 },
              { x: 1960, y: 360 },
              { x: 2000, y: 360 },
              { x: 2320, y: 360 },
              { x: 1480, y: 400 },
              { x: 2360, y: 400 },
              { x: 1560, y: 480 },
              { x: 1680, y: 520 },
              { x: 1720, y: 520 },
              { x: 1760, y: 520 },
              { x: 1800, y: 520 }
            ],
            coins: [
              { x: 1680, y: 160 },
              { x: 1560, y: 200 },
              { x: 1800, y: 200 },
              { x: 2200, y: 200 },
              { x: 2240, y: 200 },
              { x: 920, y: 240 },
              { x: 1400, y: 280 },
              { x: 2120, y: 280 },
              { x: 2480, y: 280 },
              { x: 2520, y: 280 },
              { x: 2760, y: 280 },
              { x: 2800, y: 280 },
              { x: 760, y: 320 },
              { x: 920, y: 320 },
              { x: 960, y: 320 },
              { x: 1240, y: 320 },
              { x: 1280, y: 320 },
              { x: 1920, y: 320 },
              { x: 1960, y: 320 },
              { x: 2000, y: 320 },
              { x: 2320, y: 320 },
              { x: 2360, y: 360 },
              { x: 720, y: 400 },
              { x: 40, y: 480 },
              { x: 80, y: 480 },
              { x: 240, y: 480 },
              { x: 280, y: 480 },
              { x: 440, y: 480 },
              { x: 480, y: 480 },
              { x: 680, y: 480 },
              { x: 720, y: 480 },
              { x: 1720, y: 480 },
              { x: 1760, y: 480 },
              { x: 1800, y: 480 }
            ],
            spikyBalls: [
              { x: 800, y: 400 }
            ],
            
            spikes: [
              { x: 1120, y: 320 },
              { x: 1160, y: 320 },
              { x: 1200, y: 320 },
              { x: 120, y: 480 },
              { x: 160, y: 480 },
              { x: 200, y: 480 },
              { x: 320, y: 480 },
              { x: 360, y: 480 },
              { x: 400, y: 480 },
              { x: 520, y: 480 },
              { x: 560, y: 480 },
              { x: 600, y: 480 }
            ],
            enemies: [
              { x: 1040, y: 320, type: 1 },
              { x: 1320, y: 320, type: 1 }
            ],
        },
      }

      const transitionEventsEmitter = new Phaser.Events.EventEmitter()

      function stringifyTime(elapsed) {
        const minutes = Math.floor(elapsed / 60000)
        const seconds = Math.floor((elapsed % 60000) / 1000)
        const centiseconds = Math.floor(elapsed % 1000)
        return (
          Phaser.Utils.String.Pad(minutes, 2, '0', 1) +
          "'" +
          Phaser.Utils.String.Pad(seconds, 2, '0', 1) +
          '"' +
          Phaser.Utils.String.Pad(centiseconds, 3, '0', 1)
        )
      }

      function getUnlockedLevels() {
        const unlockedLevelsString = localStorage.getItem('unlockedLevels')
        if (unlockedLevelsString) {
          return JSON.parse(unlockedLevelsString)
        } else {
          const level = {
            level: 1,
            time: 0,
          }
          localStorage.setItem('unlockedLevels', JSON.stringify([level]))
          return [level]
        }
      }

      function getLevelInfo(levelNum) {
        const unlockedLevels = getUnlockedLevels()
        return unlockedLevels.find(({ level }) => level === levelNum)
      }

      function updateLevelInfo(levelNum, data) {
        const unlockedLevels = getUnlockedLevels()
        const index = unlockedLevels.findIndex(({ level }) => level === levelNum)
        if (index === -1) return

        unlockedLevels[index] = { ...unlockedLevels[index], ...data }
        localStorage.setItem('unlockedLevels', JSON.stringify(unlockedLevels))
      }

      function unlockLevel(levelNum, time = 0) {
        const unlockedLevels = getUnlockedLevels()
        if (unlockedLevels.some(({ level }) => level === levelNum)) return

        unlockedLevels.push({
          level: levelNum,
          time,
        })
        localStorage.setItem('unlockedLevels', JSON.stringify(unlockedLevels))
      }

      function unlockAllLevels() {
        let unlockedLevels = getUnlockedLevels()
        const unlockedLevelSet = new Set(unlockedLevels.map((levelData) => levelData.level))
        for (let level = 1; level <= Object.keys(levelsData).length; level++) {
          if (!unlockedLevelSet.has(level)) {
            unlockedLevels.push({ level, time: 0 })
          }
        }

        localStorage.setItem('unlockedLevels', JSON.stringify(unlockedLevels))
      }

      function resetBestTimes() {
        const unlockedLevels = getUnlockedLevels()
        const resetTimesLevels = unlockedLevels.map((level) => ({ ...level, time: 0 }))
        localStorage.setItem('unlockedLevels', JSON.stringify(resetTimesLevels))
      }

      class PreloaderScene extends Phaser.Scene {
        constructor() {
          super({ key: 'preloader' })
        }

        preload() {
          const { width, height } = this.scale
          const text = this.add
            .text(width / 2, height / 2 - 24, 'Chargement...', { fontSize: '24px', fill: '#1d2b53' })
            .setOrigin(0.5, 0.5)

          const progressBox = this.add.graphics()
          progressBox.lineStyle(4, 0x1d2b53)
          progressBox.strokeRect(width / 2 - 102, height / 2, 204, 40)

          this.progressBar = this.add.graphics()
          this.load.on('progress', this.onProgress, this)
        }

        create() {
          this.scene.start('intro')
        }

        onProgress(val) {
          const { width, height } = this.scale
          const [progressWidth, progressHeight] = [200, 38]

          this.progressBar.clear()
          this.progressBar.fillStyle(0x1d2b53, 1)
          this.progressBar.fillRect(width / 2 - progressWidth / 2, height / 2, progressWidth * val, progressHeight)
        }
      }

      class SettingsScene extends Phaser.Scene {
        constructor() {
          super({ key: 'settings' })
        }

        create() {
          const btnBack = this.add.sprite(40, 40, 'btnBack')
          btnBack.setInteractive()
          btnBack.on('pointerdown', this.goBack, this)

          // Paramètres de jeu sur 2 colonnes
          this.add.text(480, 60, '- Paramètres -', { fontSize: '32px', fill: '#1d2b53' }).setOrigin(0.5)

          const btnModeBg = this.add.rectangle(0, 0, 360, 80, 0xffffff)
          this.btnModeText = this.add.text(0, 0, this.getModeText(), { fontSize: '24px', fill: '#1d2b53' })
          Phaser.Display.Align.In.Center(this.btnModeText, btnModeBg)
          const btnMode = this.add.container(280, 160, [btnModeBg, this.btnModeText])
          btnMode.setSize(360, 80)
          btnMode.setInteractive()
          btnMode.on('pointerdown', this.handleChangeMode, this)

          const btnSoundBg = this.add.rectangle(0, 0, 360, 80, 0xffffff)
          this.btnSoundText = this.add.text(0, 0, this.getMuteStateText(), { fontSize: '24px', fill: '#1d2b53' })
          Phaser.Display.Align.In.Center(this.btnSoundText, btnSoundBg)
          const btnSound = this.add.container(680, 160, [btnSoundBg, this.btnSoundText])
          btnSound.setSize(360, 80)
          btnSound.setInteractive()
          btnSound.on('pointerdown', this.handleToggleSound, this)

          const btnUnlockBg = this.add.rectangle(0, 0, 360, 80, 0xffffff)
          const btnUnlockText = this.add.text(0, 0, 'Débloquer les niveaux', { fontSize: '24px', fill: '#1d2b53' })
          Phaser.Display.Align.In.Center(btnUnlockText, btnUnlockBg)
          const btnUnlock = this.add.container(280, 260, [btnUnlockBg, btnUnlockText])
          btnUnlock.setSize(360, 80)
          btnUnlock.setInteractive()
          btnUnlock.on('pointerdown', unlockAllLevels)

          const btnResetTimesBg = this.add.rectangle(0, 0, 360, 80, 0xffffff)
          const btnResetTimesText = this.add.text(0, 0, 'Reset meilleurs temps', { fontSize: '24px', fill: '#1d2b53' })
          Phaser.Display.Align.In.Center(btnResetTimesText, btnResetTimesBg)
          const btnResetTimes = this.add.container(680, 260, [btnResetTimesBg, btnResetTimesText])
          btnResetTimes.setSize(360, 80)
          btnResetTimes.setInteractive()
          btnResetTimes.on('pointerdown', resetBestTimes)

          // Statistiques du joueur
          const totalKilled = Number(localStorage.getItem(ANALYTICS_ENEMY_KILLED)) || 0
          const totalDeath = Number(localStorage.getItem(ANALYTICS_PLAYER_DEATH)) || 0

          this.add.text(480, 380, '- Statistiques -', { fontSize: '32px', fill: '#1d2b53' }).setOrigin(0.5)
          this.add
            .text(480, 440, `Ennemis tués : ${totalKilled}\nMorts de Bobby : ${totalDeath}`, {
              fontSize: '24px',
              fill: '#1d2b53',
              align: 'right',
            })
            .setOrigin(0.5)

          this.scene.launch('transition')
        }

        getModeText() {
          const mode = this.registry.get('mode')
          return `Mode : ${mode === 'classic' ? 'Classique' : 'Speedrun'}`
        }

        getMuteStateText() {
          const isMute = this.registry.get('mute')
          return `Musique : ${isMute ? 'Non' : 'Oui'}`
        }

        handleChangeMode() {
          let mode = this.registry.get('mode')
          mode = mode === 'classic' ? 'speedrun' : 'classic'
          this.registry.set('mode', mode)
          localStorage.setItem('mode', mode)
          this.btnModeText.setText(this.getModeText())
        }

        goBack() {
          transitionEventsEmitter.emit('start')
          transitionEventsEmitter.once('end', () => this.scene.start('intro'), this)
        }

        handleToggleSound() {
          this.btnSoundText.setText(this.getMuteStateText())
        }
      }

      class TransitionScene extends Phaser.Scene {
        constructor() {
          super({ key: 'transition' })
        }

        init(data) {
          this.isOpen = data.isOpen ?? false
        }

        create() {
          this.scene.bringToTop()
          const { width, height } = this.scale

          this.rect1 = this.add.rectangle(0, this.isOpen ? -height / 2 : 0, width, height / 2, 0x1d2b53)
          this.rect1.setOrigin(0, 0)
          this.rect2 = this.add.rectangle(0, this.isOpen ? height : height / 2, width, height / 2, 0x1d2b53)
          this.rect2.setOrigin(0, 0)

          transitionEventsEmitter.off('start', this.startTransition, this)
          transitionEventsEmitter.on('start', this.startTransition, this)

          this.startTransition()
        }

        startTransition() {
          if (this.isOpen) {
            this.input.keyboard.manager.enabled = false
            this.input.mouse.enabled = false
          }

          const { width, height } = this.scale

          this.tweens.add({
            targets: this.rect1,
            y: this.isOpen ? 0 : -height / 2,
            duration: 500,
            ease: 'Cubic.Out',
          })

          this.tweens.add({
            targets: this.rect2,
            y: this.isOpen ? height / 2 : height,
            duration: 500,
            ease: 'Cubic.Out',
            onComplete: () => {
              if (this.isOpen) {
                this.input.keyboard.manager.enabled = true
                this.input.mouse.enabled = true
              }
              transitionEventsEmitter.emit('end')
            },
          })

          this.isOpen = !this.isOpen
        }
      }

      class HUDScene extends Phaser.Scene {
        constructor() {
          super({ key: 'hud' })
        }

        create() {
          const graphics = this.make.graphics()

          if (!this.sys.game.device.os.desktop) {
            graphics.lineStyle(2, 0xffffff, 1)
            graphics.strokeRect(0, 0, 100, 100)
            graphics.fillStyle(0xffffff, 1)
            graphics.beginPath()
            graphics.moveTo(40, 40)
            graphics.lineTo(40, 60)
            graphics.lineTo(60, 50)
            graphics.closePath()
            graphics.fillPath()
            graphics.generateTexture('btnRight', 100, 100)
            graphics.clear()

            graphics.lineStyle(2, 0xffffff, 1)
            graphics.strokeRect(0, 0, 100, 100)
            graphics.fillStyle(0xffffff, 1)
            graphics.beginPath()
            graphics.moveTo(60, 40)
            graphics.lineTo(60, 60)
            graphics.lineTo(40, 50)
            graphics.closePath()
            graphics.fillPath()
            graphics.generateTexture('btnLeft', 100, 100)

            this.add.sprite(40, 420, 'btnLeft').setOrigin(0)
            this.add.sprite(160, 420, 'btnRight').setOrigin(0)
          }

          // Bouton pause
          graphics.fillStyle(0xffffff, 1)
          graphics.fillRect(0, 0, 40, 40)
          graphics.fillStyle(0x1d2b53, 1)
          graphics.fillRect(10, 10, 8, 20)
          graphics.fillRect(22, 10, 8, 20)
          graphics.generateTexture('btnPause', 40, 40)
          graphics.clear()

          // Bouton play
          graphics.fillStyle(0xffffff, 1)
          graphics.fillRect(0, 0, 40, 40)
          graphics.fillStyle(0x1d2b53, 1)
          graphics.beginPath()
          graphics.moveTo(10, 10)
          graphics.lineTo(10, 30)
          graphics.lineTo(30, 20)
          graphics.closePath()
          graphics.fillPath()
          graphics.generateTexture('btnPlay', 40, 40)
          graphics.clear()

          // Bouton restart
          graphics.fillStyle(0xffffff, 1)
          graphics.fillRect(0, 0, 40, 40)
          graphics.fillStyle(0x1d2b53, 1)
          graphics.beginPath()
          graphics.moveTo(20, 10)
          graphics.lineTo(30, 20)
          graphics.lineTo(20, 30)
          graphics.lineTo(10, 20)
          graphics.closePath()
          graphics.fillPath()
          graphics.generateTexture('btnRestart', 40, 40)
          graphics.clear()

          // Bouton niveaux
          graphics.fillStyle(0xffffff, 1)
          graphics.fillRect(0, 0, 40, 40)
          graphics.fillStyle(0x1d2b53, 1)
          graphics.fillRect(8, 8, 10, 10)
          graphics.fillRect(22, 8, 10, 10)
          graphics.fillRect(8, 22, 10, 10)
          graphics.fillRect(22, 22, 10, 10)
          graphics.generateTexture('btnLevels', 40, 40)
          graphics.destroy()

          const gameScene = this.scene.get('game')

          const btnPause = this.add.sprite(900, 20, 'btnPause')
          btnPause.setOrigin(0).setInteractive()
          btnPause.on('pointerdown', this.togglePause, this)
          this.input.keyboard.on('keydown-P', this.togglePause, this)
          this.input.keyboard.on('keydown-ESC', this.togglePause, this)

          // Pièces
          this.coinsCollected = 0
          this.add.circle(20, 20, 10, 0xffec27)
          this.coinsText = this.add.text(36, 10, 'x00', { fontSize: '24px', fill: '#ffffff' })
          gameScene.events.on('collectCoin', this.updateCoins, this)

          const isSpeedrunMode = this.registry.get('mode') === 'speedrun'
          this.timerStarted = false
          this.startTime = 0
          const timerBg = this.add.rectangle(0, 40, 170, 40, 0x1d2b53, 0.5).setOrigin(0)
          this.timerText = this.add.text(20, 48, '00\'00"000', { fontSize: '24px', fill: '#ffffff' })
          const timerContainer = this.add.container(0, 0, [timerBg, this.timerText])
          timerContainer.setAlpha(isSpeedrunMode ? 1 : 0)

          gameScene.events.on('startTimer', this.startTimer, this)
          gameScene.events.on('stopTimer', this.stopTimer, this)
          gameScene.events.on('levelEnd', this.handleLevelEnd, this)

          // Panel
          const { width, height } = this.scale
          const [panelWidth, panelHeight] = [320, 180]
          const [centerX, centerY] = [(width - panelWidth) / 2, (height - panelHeight) / 2]

          this.panelPause = this.add.container(0, 0)
          this.panelPause.setVisible(false)

          const panelOverlay = this.add.rectangle(0, 0, width, height, 0x1d2b53, 0.4)
          panelOverlay.setOrigin(0).setInteractive()

          const panelPauseBg = this.add.rectangle(centerX, centerY, panelWidth, panelHeight, 0x1d2b53).setOrigin(0)
          const panelTxt = this.add
            .text(width / 2, centerY + 20, 'PAUSE', { fontSize: '32px', fill: '#ffffff' })
            .setOrigin(0.5, 0)

          const btnPlay = this.add.sprite(width / 2, height / 2 + 20, 'btnPlay').setInteractive()
          btnPlay.on('pointerdown', this.togglePause, this)

          const btnRestart = this.add.sprite(width / 2 + 60, height / 2 + 20, 'btnRestart').setInteractive()
          btnRestart.on('pointerdown', this.restartCurrentLevel, this)

          const btnLevels = this.add.sprite(width / 2 - 60, height / 2 + 20, 'btnLevels').setInteractive()
          btnLevels.on('pointerdown', this.goToLevels, this)

          this.panelPause.add([panelOverlay, panelPauseBg, panelTxt, btnPlay, btnRestart, btnLevels])

          this.events.once('shutdown', this.handleShutdown, this)
        }

        handleShutdown() {
          const gameScene = this.scene.get('game')
          gameScene.events.off('startTimer', this.startTimer, this)
          gameScene.events.off('stopTimer', this.stopTimer, this)
          gameScene.events.off('levelEnd', this.handleLevelEnd, this)
          gameScene.events.off('collectCoin', this.updateCoins, this)
        }

        goToLevels() {
          transitionEventsEmitter.emit('start')
          transitionEventsEmitter.once(
            'end',
            () => {
              this.registry.set('isPaused', false)
              const gameScene = this.scene.get('game')
              gameScene.scene.start('levels')
            },
            this
          )
        }

        restartCurrentLevel() {
          transitionEventsEmitter.emit('start')
          transitionEventsEmitter.once(
            'end',
            () => {
              this.registry.set('isPaused', false)
              this.scene.start('game')
              this.scene.restart('hud')
            },
            this
          )
        }

        togglePause() {
          const isPaused = this.registry.get('isPaused')
          if (isPaused) {
            this.scene.resume('game')
            this.pauseTime = this.time.now - this.pauseTime
            this.startTime += this.pauseTime
          } else {
            this.scene.pause('game')
            this.scene.get('game').resetPointers()
            this.pauseTime = this.time.now
          }

          this.panelPause.setVisible(!isPaused)
          this.registry.set('isPaused', !isPaused)
        }

        handleLevelEnd(currentLevel) {
          this.stopTimer.call(this)

          const levelInfo = getLevelInfo(currentLevel)
          if (!levelInfo) return

          const previousBestTime = levelInfo.time || Infinity
          const newTime = this.time.now - this.startTime
          const previousMaxCoins = levelInfo.coins || 0

          updateLevelInfo(currentLevel, {
            ...(newTime < previousBestTime && { time: newTime }),
            ...(this.coinsCollected > previousMaxCoins && { coins: this.coinsCollected }),
          })

          this.startTime = 0
        }

        stopTimer() {
          const isSpeedrunMode = this.registry.get('mode') === 'speedrun'
          if (!this.timerStarted || !isSpeedrunMode) return
          this.timerStarted = false
        }

        startTimer() {
          this.timerStarted = true
          this.startTime = this.time.now
        }

        updateCoins() {
          this.coinsCollected += 1
          this.coinsText.setText(`x${this.coinsCollected.toString().padStart(2, '0')}`)
        }

        update() {
          const isPaused = this.registry.get('isPaused')

          if (this.startTime === 0 || !this.timerStarted || isPaused) return
          const time = stringifyTime(this.time.now - this.startTime)
          this.timerText.setText(time)
        }
      }

      class IntroScene extends Phaser.Scene {
        constructor() {
          super({ key: 'intro' })
        }

        preload() {
          const mode = localStorage.getItem('mode') || 'classic'
          this.registry.set('mode', mode)

          const graphics = this.make.graphics()
          graphics.fillStyle(0xffffff, 1)
          graphics.fillRect(0, 0, 40, 40)
          graphics.fillStyle(0x1d2b53, 1)
          graphics.beginPath()
          graphics.moveTo(30, 10)
          graphics.lineTo(30, 30)
          graphics.lineTo(10, 20)
          graphics.closePath()
          graphics.fillPath()
          graphics.generateTexture('btnBack', 40, 40)
          graphics.clear()

          graphics.fillStyle(0xffffff, 1)
          graphics.fillRect(0, 0, 40, 40)
          graphics.fillStyle(0x1d2b53, 1)
          graphics.fillTriangle(5, 27.5, 35, 27.5, 20, 5)
          graphics.generateTexture('btnSettings', 40, 40)
          graphics.destroy()
        }

        create() {
          const btnSettings = this.add.sprite(900, 20, 'btnSettings')
          btnSettings.setOrigin(0).setInteractive()
          btnSettings.on('pointerdown', this.goToSettings, this)

          const text = this.add
            .text(
              480,
              460,
              `${this.sys.game.device.os.desktop ? "Appuie sur la touche 'ESPACE'" : "Touche l'écran"} pour commencer`,
              { fontSize: '24px', fill: '#1d2b53' }
            )
            .setOrigin(0.5, 0.5)

          this.tweens.add({
            targets: text,
            duration: 1000,
            alpha: 0,
            repeat: -1,
            yoyo: true,
          })

          this.add
            .text(480, 200, 'Bob 1 - aventure', {
              fontSize: '88px',
              fill: '#1d2b53',
            })
            .setOrigin(0.5, 0.5)

          this.add
            .text(480, 280, 'Pas sur du titre', {
              fontSize: '24px',
              fill: '#1d2b53',
            })
            .setOrigin(0.5, 0.5)

          this.input.keyboard.on('keydown-SPACE', this.startGame, this)
          this.input.on('pointerdown', this.startGame, this)

          this.scene.launch('transition')
        }

        goToSettings(pointer, localX, localY, event) {
          event.stopPropagation()
          transitionEventsEmitter.emit('start')
          transitionEventsEmitter.once('end', () => this.scene.start('settings'), this)
        }

        startGame() {
          transitionEventsEmitter.emit('start')
          transitionEventsEmitter.once('end', () => this.scene.start('levels'), this)
        }
      }

      class LevelsScene extends Phaser.Scene {
        constructor() {
          super({ key: 'levels' })
        }

        create() {
          this.scene.stop('hud')
          this.registry.set('isCheckpointActive', false)
          const unlockedLevels = getUnlockedLevels()

          const btnBack = this.add.sprite(40, 40, 'btnBack')
          btnBack.setInteractive()
          btnBack.on('pointerdown', () => this.goToScreen('intro'))

          // Niveaux
          const buttonOffset = 48
          const buttonSize = 80
          const buttonsPerCol = 2
          const buttonsPerRow = Math.ceil(NUM_LEVELS / buttonsPerCol)

          const totalButtonsWidth = (buttonSize + buttonOffset) * (buttonsPerRow - 1)
          const totalButtonsHeight = (buttonSize + buttonOffset) * (buttonsPerCol - 1)
          const startX = this.cameras.main.centerX - totalButtonsWidth / 2
          const startY = this.cameras.main.centerY - totalButtonsHeight / 2

          for (let i = 0; i < NUM_LEVELS; i++) {
            const level = i + 1
            const col = Math.floor(i / buttonsPerCol)
            const row = i % buttonsPerCol
            const direction = i % 2 ? 1 : -1

            const x = startX + col * (buttonSize + buttonOffset) + ((buttonSize + buttonOffset) / 4) * direction
            const y = startY + row * (buttonSize + buttonOffset) - ((buttonSize + buttonOffset) / 4) * direction
            const timePosY = y + buttonSize * direction

            const button = this.add.rectangle(x, y, buttonSize, buttonSize, 0x1d2b53)

            const levelInfo = getLevelInfo(level)
            button.rotation = Phaser.Math.DegToRad(45)

            if (levelInfo) {
              button.setInteractive()
              button.on('pointerdown', () => this.goToScreen('game', { level }))
            } else {
              button.alpha = 0.5
            }

            const time = (levelInfo && levelInfo.time) || 0
            const mode = this.registry.get('mode')
            if (time && mode === 'speedrun') {
              this.add.rectangle(x, timePosY, 100, 30, 0xffffff).setOrigin(0.5)
              this.add
                .text(x, timePosY, time ? stringifyTime(levelInfo.time) : '10\'00"00', {
                  color: '#1d2b53',
                  fontSize: '16px',
                })
                .setOrigin(0.5)
            }

            this.add.text(x, y, (i + 1).toString(), { color: '#ffffff', fontSize: '32px' }).setOrigin(0.5)

            // Pièces max
            const coins = (levelInfo && levelInfo.coins) || 0
            const levelTotalCoins = (levelsData[`level${level}`]?.coins || []).reduce(
              (acc, cur) => acc + Math.max(cur.numX || 1, cur.numY || 1),
              0
            )
            if (coins > 0 && coins === levelTotalCoins) {
              this.add.circle(x, y + 24, 4, 0xffec27)
            }
          }

          this.scene.launch('transition')
        }

        goToScreen(screen, params = {}) {
          transitionEventsEmitter.emit('start')
          transitionEventsEmitter.once('end', () => this.scene.start(screen, params), this)
        }
      }

      class GameScene extends Phaser.Scene {
        constructor() {
          super({ key: 'game' })
        }

        init(data) {
          this.currentLevel = data.level
          this.levelData = levelsData[`level${this.currentLevel}`]
        }

        preload() {
          const graphics = this.make.graphics()
          graphics.fillStyle(0x000000, 1)
          graphics.fillRect(0, 0, 10, 10)
          graphics.generateTexture('particle', 10, 10)
          graphics.clear()

          graphics.fillStyle(0xffffff, 0.4)
          graphics.fillRect(0, 0, 10, 10)
          graphics.generateTexture('particleTransformer', 10, 10)
          graphics.clear()

          graphics.fillStyle(0xc2c3c7, 1)
          graphics.fillCircle(10, 10, 10)
          graphics.generateTexture('particleJump', 20, 20)
          graphics.clear()

          graphics.fillStyle(0xffec27, 1)
          graphics.fillRect(0, 0, 10, 10)
          graphics.generateTexture('particleCoin', 10, 10)
          graphics.clear()

          graphics.fillStyle(0xffa300, 1)
          graphics.fillCircle(10, 10, 10)
          graphics.generateTexture('fireball', 20, 20)
          graphics.clear()

          graphics.fillStyle(0xc2c3c7, 1)
          graphics.beginPath()
          graphics.moveTo(0, 40)
          graphics.lineTo(20, 0)
          graphics.lineTo(40, 40)
          graphics.closePath()
          graphics.fillPath()
          graphics.generateTexture('spike', 40, 40)
          graphics.clear()

          graphics.fillStyle(0xff004d, 1)
          graphics.beginPath()
          graphics.moveTo(0, 40)
          graphics.lineTo(20, 0)
          graphics.lineTo(40, 40)
          graphics.closePath()
          graphics.fillPath()
          graphics.generateTexture('enemy2', 40, 40)
          graphics.clear()

          graphics.fillStyle(0xc2c3c7, 1)
          graphics.beginPath()
          graphics.moveTo(20, 1)
          graphics.lineTo(39, 20)
          graphics.lineTo(20, 39)
          graphics.lineTo(1, 20)
          graphics.closePath()
          graphics.fillPath()
          graphics.fillStyle(0x000000, 1)
          graphics.fillCircle(20, 20, 15)
          graphics.generateTexture('spikyBall', 40, 40)
          graphics.clear()

          graphics.fillStyle(0xffffff, 1)
          graphics.fillCircle(30, 30, 30)
          graphics.fillCircle(50, 50, 30)
          graphics.fillCircle(70, 30, 30)
          graphics.fillCircle(90, 50, 30)
          graphics.fillCircle(120, 30, 30)
          graphics.generateTexture('cloud', 150, 120)
          graphics.clear()

          graphics.fillStyle(0x008751, 1)
          graphics.beginPath()
          graphics.moveTo(0, 800)
          graphics.lineTo(400, 0)
          graphics.lineTo(800, 800)
          graphics.closePath()
          graphics.fillPath()
          graphics.generateTexture('hill', 800, 800)
          graphics.clear()

          graphics.fillStyle(0x5f574f, 1)
          graphics.beginPath()
          graphics.moveTo(0, 800)
          graphics.lineTo(400, 0)
          graphics.lineTo(800, 800)
          graphics.closePath()
          graphics.fillPath()
          graphics.generateTexture('hill2', 800, 800)
          graphics.destroy()
        }

        create() {
          this.canMove = false
          this.isReady = false
          this.touchLeft = false
          this.touchRight = false
          this.timerStarted = false
          this.playerMode = PLAYER_MODE_PLATFORM
          this.isCheckpointActive = this.registry.get('isCheckpointActive')
          this.isSpeedrunMode = this.registry.get('mode') === 'speedrun'
          this.time.delayedCall(
            500,
            () => {
              this.isReady = true
            },
            [],
            this
          )
          this.isUpKeyPressed = false
          this.isTransitionning = false
          this.playerWasStanding = false
          this.worldWidth = this.levelData.world.width
          this.worldHeight = this.levelData.world.height
          this.physics.world.setBounds(0, 0, this.worldWidth, this.worldHeight)

          const hillsPos = this.levelData.hills ?? []
          this.hills = this.add.group()
          for (let i = 0; i < hillsPos.length; i++) {
            let hill = this.hills.create(hillsPos[i].x, hillsPos[i].y, 'hill')
            hill.setOrigin(0)
            hill.setScrollFactor(0.3)
          }

          const hillsPos2 = this.levelData.hillsFront ?? []
          this.hills2 = this.add.group()
          for (let i = 0; i < hillsPos2.length; i++) {
            let hill = this.hills2.create(hillsPos2[i].x, hillsPos2[i].y, 'hill2')
            hill.setOrigin(0)
            hill.setScrollFactor(0.4)
          }

          const cloudsPos = this.levelData.clouds?.x ?? []
          this.clouds = this.physics.add.group({
            allowGravity: false,
          })
          for (let i = 0; i < cloudsPos.length; i++) {
            let cloud = this.clouds.create(
              cloudsPos[i],
              Phaser.Math.Between(this.levelData.clouds.y.min, this.levelData.clouds.y.max),
              'cloud'
            )
            cloud.setVelocityX(Phaser.Math.Between(10, 20))
            cloud.setAlpha(Phaser.Math.FloatBetween(0.2, 0.8))
          }

          // Plateformes
          this.platforms = this.physics.add.staticGroup()
          const platformsPos = this.levelData.platforms || []
          for (let i = 0; i < platformsPos.length; i++) {
            const { x, y, width, height } = platformsPos[i]
            this.addPlatform(this.platforms, x, y, width, height)
          }

          // Plateformes à sens unique
          this.oneWayPlatforms = this.physics.add.group({
            allowGravity: false,
            immovable: true,
          })
          const oneWayPlatformsPos = this.levelData.oneWayPlatforms || []
          for (let i = 0; i < oneWayPlatformsPos.length; i++) {
            this.addOneWayPlatform(this.oneWayPlatforms, oneWayPlatformsPos[i])
          }

          // Canons
          this.cannons = this.physics.add.staticGroup()
          const cannonsPos = this.levelData.cannons || []
          for (let i = 0; i < cannonsPos.length; i++) {
            this.addCannon(this.cannons, cannonsPos[i])
          }

          this.fireballs = this.physics.add.group({
            allowGravity: false,
          })

          // Créer le téléporteur et les particules
          const particles = this.add.particles(this.levelData.target.x, this.levelData.target.y, 'particle', {
            speed: { min: -100, max: 100 },
            angle: { min: 0, max: 360 },
            scale: { start: 1, end: 0 },
            lifespan: 1000,
            frequency: 100,
            quantity: 5,
          })

          this.target = this.add.circle(this.levelData.target.x, this.levelData.target.y, 20, 0x1d2b53)
          this.physics.add.existing(this.target, true)
          this.target.body.setCircle(40)
          this.target.body.setOffset(-20, -20)

          // Pics
          const spikes = this.physics.add.staticGroup()
          const spikesPos = this.levelData.spikes ?? []
          for (let i = 0; i < spikesPos.length; i++) {
            const { x, y } = spikesPos[i]
            this.addSpike(spikes, spikesPos[i])
          }

          const spikyBalls = this.physics.add.group({
            allowGravity: false,
            immovable: true,
          })
          const spikyBallsPos = this.levelData.spikyBalls ?? []
          for (let i = 0; i < spikyBallsPos.length; i++) {
            this.addSpikyBall(spikyBalls, spikyBallsPos[i])
          }

          // Plateformes sensibles
          this.fallingBlocks = this.physics.add.staticGroup()
          this.fallingBlocksTriggers = this.physics.add.staticGroup()
          const fallingBlocksPos = this.levelData.fallingBlocks ?? []
          for (let i = 0; i < fallingBlocksPos.length; i++) {
            this.addFallingBlock(this.fallingBlocks, this.fallingBlocksTriggers, fallingBlocksPos[i])
          }

          // Transformers
          this.transformers = this.physics.add.staticGroup()
          const transformersPos = this.levelData.transformers ?? []
          for (let i = 0; i < transformersPos.length; i++) {
            this.addTransformer(this.transformers, transformersPos[i])
          }

          // Ennemis
          this.enemies = this.physics.add.group()
          const enemiesPos = this.levelData.enemies ?? []
          for (let i = 0; i < enemiesPos.length; i++) {
            this.addEnemy(this.enemies, enemiesPos[i])
          }

          // Pièces
          this.coins = this.physics.add.staticGroup()
          const coinsPos = this.levelData.coins || []
          for (let i = 0; i < coinsPos.length; i++) {
            this.addCoin(this.coins, coinsPos[i])
          }

          // Checkpoint
          if (this.levelData.checkpoint && !this.isSpeedrunMode) {
            const pole = this.add.rectangle(0, 0, 10, 120, 0xc2c3c7)
            this.checkpointFlag = this.add
              .triangle(45, pole.height / 2 - 4 - (this.isCheckpointActive ? 60 : 0), 0, -20, 40, 0, 0, 20, 0xffa300)
              .setOrigin(1, 0.5)
            this.checkpoint = this.add.container(this.levelData.checkpoint.x, this.levelData.checkpoint.y, [
              pole,
              this.checkpointFlag,
            ])
            this.physics.add.existing(this.checkpoint, true)
            this.checkpoint.body.setSize(pole.width, pole.height)
            this.checkpoint.body.setOffset(26, -28)
          }

          // Créer le joueur
          const startingPos = this.isCheckpointActive
            ? { x: this.levelData.checkpoint.x - 40, y: this.levelData.checkpoint.y }
            : this.levelData.player
          this.player = this.add.container(startingPos.x, startingPos.y)
          this.playerSprite = this.add.rectangle(0, 0, 40, 40, 0xfff1e8)
          this.player.add(this.playerSprite)
          this.player.setSize(40, 40)
          this.physics.world.enable(this.player)
          this.jumpCount = 0
          this.playerDir = 1
          this.prevVelocityY = 0

          this.playerShadowHitbox = this.add.rectangle(
            this.levelData.player.x,
            this.levelData.player.y,
            40,
            40,
            0xfff1e8,
            0
          )
          this.physics.add.existing(this.playerShadowHitbox, true)

          // Particules du joueur lors du saut
          this.playerEmitter = this.add.particles(0, 0, 'particleJump', {
            lifespan: 300,
            speedX: { min: -100, max: 100 },
            speedY: 0,
            scale: { start: 1, end: 0 },
            emitting: false,
            quantity: 5,
          })

          // Particules pièces
          this.coinsEmitter = this.add.particles(0, 0, 'particleCoin', {
            lifespan: 300,
            speed: { min: 80, max: 100 },
            angle: { min: 0, max: 360 },
            frequency: -1,
            scale: { start: 1, end: 0.2 },
            alpha: { start: 1, end: 0 },
          })

          // Mort du joueur
          this.physics.add.overlap(this.player, spikes, this.die, undefined, this)
          this.physics.add.overlap(this.player, this.fireballs, this.die, undefined, this)
          this.physics.add.overlap(this.player, spikyBalls, this.die, undefined, this)
          this.enemiesCollider = this.physics.add.overlap(
            this.enemies,
            this.player,
            this.handleEnemiesCollision,
            undefined,
            this
          )

          // Ajouter la collision entre le joueur, les ennemis et le sol
          this.physics.add.overlap(this.platforms, this.fireballs, this.destroyFireball, undefined, this)
          this.platformsCollider = this.physics.add.collider(this.player, this.platforms)
          this.cannonsCollider = this.physics.add.collider(this.player, this.cannons)
          this.oneWayPlatformsCollider = this.physics.add.collider(
            this.player,
            this.oneWayPlatforms,
            this.stickPlayerToPlatform,
            null,
            this
          )
          this.physics.add.collider(this.enemies, this.platforms)
          this.physics.add.collider(this.enemies, this.oneWayPlatforms)
          this.physics.add.collider(this.enemies, this.fallingBlocks)
          this.fallingBlocksCollider = this.physics.add.collider(this.player, this.fallingBlocks)
          this.fallingBlocksTriggers = this.physics.add.overlap(
            this.player,
            this.fallingBlocksTriggers,
            this.handleFallingBlockCollision,
            undefined,
            this
          )
          this.transformersTriggers = this.physics.add.overlap(
            this.player,
            this.transformers,
            this.handleTransformerCheck,
            undefined,
            this
          )

          // Détection checkpoint
          if (this.levelData.checkpoint && !this.isCheckpointActive) {
            this.checkpointTrigger = this.physics.add.overlap(
              this.player,
              this.checkpoint,
              this.handleCheckpoint,
              null,
              this
            )
          }

          // Pièces
          this.coinsTriggers = this.physics.add.overlap(this.player, this.coins, this.handleCoin, null, this)

          // Detection de fin de jeu
          this.targetTrigger = this.physics.add.overlap(this.player, this.target, this.teleport, undefined, this)

          // Suivi de la caméra
          this.cameras.main.startFollow(this.player, true, 0.1, 0.1)
          this.cameras.main.setBounds(0, 0, this.worldWidth, this.worldHeight)

          // Créer les contrôles
          this.cursors = this.input.keyboard.createCursorKeys()
          this.keys = this.input.keyboard.addKeys('Q,D')
          this.zKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.Z)
          this.upKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.UP)
          this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE)
          this.input.keyboard.on('keyup-UP', this.resetJump, this)
          this.input.keyboard.on('keyup-Z', this.resetJump, this)
          this.input.keyboard.on('keyup-SPACE', this.resetJump, this)
          this.input.keyboard.on('keydown-R', this.handlRestartToggle, this)

          // Mobiles
          if (!this.sys.game.device.os.desktop) {
            // Pointers
            this.input.on('pointerdown', this.handlePointerDown, this)
            this.input.on('pointermove', this.handlePointerMove, this)
            this.input.on('pointerup', this.handlePointerUp, this)
          }

          // Limite horizontale du monde
          this.events.on('postupdate', this.checkWorldBounds, this)
          this.events.once('shutdown', () => {
            this.events.off('postupdate', this.checkWorldBounds)
          })

          // HUD
          this.scene.launch('hud')

          // Transition
          this.scene.launch('transition')
        }

        update(time, delta) {
          const justTriggeredJump =
            Phaser.Input.Keyboard.JustDown(this.zKey) ||
            Phaser.Input.Keyboard.JustDown(this.upKey) ||
            Phaser.Input.Keyboard.JustDown(this.spaceKey)

          const isGoingLeft = this.cursors.left.isDown || this.keys.Q.isDown || this.touchLeft
          const isGoingRight = this.cursors.right.isDown || this.keys.D.isDown || this.touchRight

          // Check du premier mouvement pour déclencher le timer
          if (justTriggeredJump || isGoingLeft || isGoingRight) this.checkFirstMove()

          // Mouvement des ennemis
          this.enemies
            .getChildren()
            .filter((enemy) => !enemy.getData('isDead'))
            .forEach((enemy) => {
              let dir = enemy.getData('dir')

              if (enemy.getData('type') === 2) {
                if (enemy.body.blocked.down) {
                  enemy.body.setVelocityX(0)
                }
              } else {
                if (enemy.body.touching.right) {
                  dir = -1
                } else if (enemy.body.touching.left) {
                  dir = 1
                }
                enemy.setData('dir', dir)
                enemy.body.setVelocityX(ENEMY_VELOCITY * dir)
              }
            })

          // Reset des nuages
          this.clouds.children.iterate((cloud) => {
            if (cloud.x > this.physics.world.bounds.width) {
              cloud.x = -120
            }
          })

          // Plateformes mobiles
          this.handleMovingPlatforms(time, delta)

          // Tirs de cannons
          this.cannons.getChildren().forEach((cannon) => {
            if (time >= cannon.getData('lastFired') + CANNON_FIRE_RATE) {
              this.shoot(cannon)
              cannon.setData('lastFired', time)
            }
          })

          if (!this.canMove) return

          if (this.player.body.velocity.y !== 0) {
            this.prevVelocityY = this.player.body.velocity.y
          }

          // Réinitialiser la vitesse horizontale du joueur
          if (this.player.body.velocity.x !== 0) {
            this.playerDir = Math.sign(this.player.body.velocity.x)
          }

          this.player.body.setVelocityX(0)

          // Gérer les mouvements à gauche et à droite
          if (isGoingLeft) {
            this.player.body.setVelocityX(-PLAYER_VELOCITY + (this.stickedVelocityX < 0 ? this.stickedVelocityX : 0))
          } else if (isGoingRight) {
            this.player.body.setVelocityX(PLAYER_VELOCITY + (this.stickedVelocityX > 0 ? this.stickedVelocityX : 0))
          }

          if (this.playerMode === PLAYER_MODE_PLATFORM) {
            // Détection de chute pour coyote time
            if (this.playerWasStanding && !this.player.body.blocked.down) {
              this.playerWasStanding = false
              this.fallStartTime = this.time.now
            } else if (
              !this.playerWasStanding &&
              this.jumpCount === 0 &&
              this.time.now - this.fallStartTime >= PLAYER_COYOTE_TIME
            ) {
              this.jumpCount = 1
            } else if (
              !this.playerWasStanding &&
              this.player.body.blocked.down &&
              this.player.body.velocity.y === 0 &&
              !justTriggeredJump
            ) {
              this.playerWasStanding = true
              this.jumpCount = 0

              if (this.prevVelocityY >= PLAYER_FALL_SQUASH_VELOCITY) {
                this.completePlayerTweens()
                this.playerEmitter.emitParticleAt(this.player.x, this.player.y + 24)
                this.tweens.add({
                  targets: this.playerSprite,
                  scaleY: 0.6,
                  scaleX: 1.4,
                  y: 8,
                  duration: 150,
                  yoyo: true,
                  ease: 'Cubic.easeOut',
                })
              }
            }

            // Jump buffering
            if (
              this.isUpKeyPressed &&
              this.player.body.blocked.down &&
              time - this.jumpBufferingTime < PLAYER_BUFFERING_TIME
            ) {
              this.jump()
            }

            // Gérer le saut progressif
            if (this.isJumping && this.isUpKeyPressed) {
              let pressDuration = time - this.jumpStartTime
              if (pressDuration > PLAYER_MAX_JUMP_TIME) {
                this.isJumping = false
                pressDuration = PLAYER_MAX_JUMP_TIME
              }

              const t = pressDuration / PLAYER_MAX_JUMP_TIME
              const jumpVelocity =
                PLAYER_MIN_JUMP_VELOCITY + (PLAYER_MAX_JUMP_VELOCITY - PLAYER_MIN_JUMP_VELOCITY) * Math.pow(t, 2)
              this.player.body.setVelocityY(jumpVelocity)
            }
          } else {
            const { y } = this.player.body.velocity

            if (y < 0) {
              this.playerSprite.angle = -20 * this.playerDir
            } else if (y > 1000) {
              this.playerSprite.angle = 90 * this.playerDir
            } else {
              this.playerSprite.angle = ((y * 90) / 1000) * this.playerDir
            }
          }

          // Z Bug, appel multiple de jump avec les events
          if (justTriggeredJump) {
            this.jump()
          }

          // Sortie du monde
          if (this.player.y - this.player.body.height / 2 > this.physics.world.bounds.height) {
            this.die.call(this)
          }
        }

        destroyFireball(player, fireball) {
          fireball.destroy()
        }

        shoot(cannon) {
          const dir = cannon.getData('dir')
          const fireball = this.fireballs.get(cannon.x + TILE_SIZE / 2, cannon.y + TILE_SIZE / 2, 'fireball')
          fireball.body.setCircle(6)
          fireball.body.setOffset(4, 4)
          if (dir === 1 || dir === 3) {
            fireball.setVelocityY(FIREBALL_VELOCITY * (dir === 1 ? -1 : 1))
          } else {
            fireball.setVelocityX(FIREBALL_VELOCITY * (dir === 2 ? 1 : -1))
          }
        }

        checkWorldBounds() {
          const playerHalfWidth = this.player.body.width / 2
          if (this.player.x - playerHalfWidth < 0) {
            this.player.x = playerHalfWidth
          } else if (this.player.x + playerHalfWidth > this.physics.world.bounds.width) {
            this.player.x = this.physics.world.bounds.width - playerHalfWidth
          }
        }

        startTimer() {
          this.timerStarted = true
          this.canMove = true
          this.events.emit('startTimer')
        }

        handlePointerDown(pointer) {
          // Saut lors du touch sur la zone droite de l'écran
          if (pointer.x > 480) {
            this.checkFirstMove()
            this.jump()
          }

          this.handlePointerMove(pointer)
        }

        handlePointerMove(pointer) {
          if (pointer.x < 150) {
            this.touchRight = false
            this.touchLeft = true
          } else if (pointer.x < 300) {
            this.touchRight = true
            this.touchLeft = false
          }
        }

        handlePointerUp(pointer) {
          if (pointer.x > 300) {
            this.resetJump()
            return
          }
          this.resetPointers()
        }

        resetPointers() {
          this.touchLeft = false
          this.touchRight = false
        }

        checkFirstMove() {
          if (!this.isReady || this.timerStarted) return
          this.startTimer()
        }

        resetJump() {
          if (!this.canMove) return
          this.isUpKeyPressed = false
          this.isJumping = false
        }

        flappyJump() {
          this.playerEmitter.emitParticleAt(this.player.x, this.player.y + 24)
          this.player.body.setVelocityY(PLAYER_FLAPPY_VELOCITY)
        }

        jump() {
          if (!this.canMove) return
          if (this.playerMode === PLAYER_MODE_FLAPPY) {
            return this.flappyJump()
          }

          this.isUpKeyPressed = true
          const isGrounded = this.player.body.blocked.down && this.player.body.velocity.y === 0

          const shouldDoubleJump = !isGrounded && this.jumpCount > 0 && this.jumpCount < PLAYER_MAX_JUMPS
          let playerAlmostLanded = false
          if (shouldDoubleJump && this.player.body.velocity.y > 0) {
            playerAlmostLanded = this.checkPlayerRightAbovePlatform()
          }

          if (
            isGrounded ||
            (!isGrounded && this.time.now - this.fallStartTime < PLAYER_COYOTE_TIME && this.jumpCount === 0) ||
            (shouldDoubleJump && !playerAlmostLanded)
          ) {
            this.jumpCount++
            this.isJumping = true
            this.jumpStartTime = this.time.now
            this.completePlayerTweens()

            if (this.jumpCount === 1) {
              this.tweens.add({
                targets: this.playerSprite,
                scaleY: 1.4,
                scaleX: 0.6,
                y: -8,
                duration: 200,
                yoyo: true,
                ease: 'Cubic.easeOut',
              })
            } else {
              this.playerEmitter.emitParticleAt(this.player.x, this.player.y + 24)
              this.tweens.add({
                targets: this.playerSprite,
                angle: 360 * this.playerDir,
                duration: 600,
                ease: 'Cubic.easeOut',
                onComplete: () => {
                  this.player.angle = 0
                },
              })
            }
          } else {
            this.jumpBufferingTime = this.time.now
          }
        }

        checkPlayerRightAbovePlatform() {
          const platformsToCheck = [
            ...this.platforms.getChildren(),
            ...this.oneWayPlatforms.getChildren(),
            ...this.fallingBlocks.getChildren(),
          ]
          this.playerShadowHitbox.x = this.player.x
          this.playerShadowHitbox.y = this.player.y + 40
          this.playerShadowHitbox.body.updateFromGameObject()
          return this.physics.overlap(this.playerShadowHitbox, this.platforms)
        }

        teleport() {
          this.canMove = false
          this.player.body.enable = false
          this.events.emit('levelEnd', this.currentLevel)

          if (this.currentLevel < NUM_LEVELS && this.currentLevel < Object.keys(levelsData).length) {
            unlockLevel(this.currentLevel + 1)
          }

          const timeline = this.add.timeline([
            {
              at: 0,
              tween: {
                targets: this.playerSprite,
                angle: 540 * this.playerDir,
                delay: 200,
                duration: 600,
                scale: 0.5,
                x: this.target.x - this.player.x,
                y: this.target.y - this.player.y,
              },
            },
            {
              at: 1200,
              tween: {
                targets: this.playerSprite,
                duration: 300,
                scale: 0,
                alpha: 0,
                ease: 'Cubic.In',
              },
            },
            {
              at: 900,
              tween: {
                targets: this.target,
                duration: 300,
                scale: 1.6,
                ease: 'Cubic.Out',
              },
            },
            {
              at: 1200,
              tween: {
                targets: this.target,
                duration: 300,
                scale: 0,
                ease: 'Cubic.In',
                onComplete: () => {
                  transitionEventsEmitter.emit('start')
                  transitionEventsEmitter.once('end', () => this.scene.start('levels'), this)
                },
              },
            },
          ])
          timeline.play()
        }

        die() {
          if (this.player.getData('isDead')) return
          this.player.setData('isDead', true)
          this.canMove = false
          this.platformsCollider.active = false
          this.cannonsCollider.active = false
          this.oneWayPlatformsCollider.active = false
          this.enemiesCollider.active = false
          this.fallingBlocksCollider.active = false
          this.fallingBlocksTriggers.active = false
          this.targetTrigger.active = false
          this.transformersTriggers.active = false
          this.coinsTriggers.active = false
          if (this.checkpointTrigger) {
            this.checkpointTrigger.active = false
          }
          this.cameras.main.stopFollow()
          this.events.emit('stopTimer')
          this.player.body.setVelocity(PLAYER_DEATH_JUMP_X * this.playerDir * -1, PLAYER_DEATH_JUMP_Y)

          this.time.delayedCall(1000, this.lose, [], this)
        }

        handlRestartToggle() {
          if (this.player.getData('isDead')) return
          this.restartGame()
        }

        restartGame() {
          if (this.isTransitionning) return

          this.isTransitionning = true
          transitionEventsEmitter.emit('start')
          transitionEventsEmitter.once('end', () => this.scene.restart(), this)
        }

        lose() {
          this.restartGame()
        }

        addPlatform(group, x, y, width, height) {
          const platform = this.add.rectangle(x, y, width, height, 0xab5236)
          platform.setOrigin(0)
          group.add(platform)
        }

        addCannon(group, data) {
          const { x, y, dir = 2 } = data
          const cannon = this.add.rectangle(x, y, TILE_SIZE, TILE_SIZE, 0x1d2b53)
          cannon.setOrigin(0)
          cannon.setData('lastFired', 0)
          cannon.setData('dir', dir)
          group.add(cannon)
        }

        addCoin(group, data) {
          const { x, y, numX = 1, numY = 1 } = data
          for (let i = 0; i < Math.max(numX, numY); i++) {
            const isHorizontal = numX >= numY
            const coin = this.add
              .circle(
                x + (isHorizontal ? TILE_SIZE * i : 0) + (TILE_SIZE - COIN_SIZE) / 2,
                y + (isHorizontal ? 0 : TILE_SIZE * i) + (TILE_SIZE - COIN_SIZE) / 2,
                COIN_SIZE / 2,
                0xffec27
              )
              .setOrigin(0)
            this.physics.add.existing(coin, true)
            coin.body.setCircle(10)
            coin.body.setOffset(5, 5)
            group.add(coin)
          }
        }

        addOneWayPlatform(group, data) {
          const { x, y, width, points } = data
          const platform = this.add.rectangle(x, y, width, 20, 0xffccaa)
          platform.setOrigin(0)
          group.add(platform)
          platform.body.checkCollision.down = false
          platform.body.checkCollision.left = false
          platform.body.checkCollision.right = false

          if (!points) return

          const path = new Phaser.Curves.Path(x, y)
          for (let i = 0; i < points.length; i++) {
            path.lineTo(points[i].x, points[i].y)
          }

          path.lineTo(x, y)
          platform.setData('isMoving', true)
          platform.setData('follower', {
            path,
            t: 0,
            vec: new Phaser.Math.Vector2(),
          })
        }

        stickPlayerToPlatform(player, platform) {
          if (!platform.getData('isMoving') || player.getData('stickedPlafform')) return
          player.setData('stickedPlatform', platform)
        }

        addSpike(group, data) {
          const { x, y, dir = 0, num = 1 } = data

          for (let i = 0; i < num; i++) {
            const spike = this.add.sprite(x + TILE_SIZE / 2 + TILE_SIZE * i, y + TILE_SIZE / 2, 'spike')
            spike.angle = dir * 90
            this.physics.add.existing(spike, true)
            spike.body.setCircle(spike.displayWidth / 3)
            spike.body.setOffset(
              dir % 2 === 0 ? spike.displayWidth / 6 : dir === 1 ? 0 : spike.displayWidth / 3,
              dir % 2 === 1 ? spike.displayWidth / 6 : dir === 0 ? spike.displayWidth / 3 : 0
            )
            group.add(spike)
          }
        }

        addSpikyBall(group, data) {
          const { x, y, points } = data
          let spikyBall

          // Création d'un path follower si des points sont définis
          if (points) {
            const path = new Phaser.Curves.Path(x, y)
            for (let i = 0; i < points.length; i++) {
              path.lineTo(points[i].x, points[i].y)
            }

            path.lineTo(x, y)
            spikyBall = this.add.follower(path, x, y, 'spikyBall')

            const pathLength = path.getLength()
            const duration = (pathLength / SPIKY_BALL_SPEED) * 1000
            spikyBall.startFollow({
              duration,
              repeat: -1,
            })
          } else {
            spikyBall = this.add.sprite(x, y, 'spikyBall')
          }
          spikyBall.setOrigin(0)
          this.physics.add.existing(spikyBall)
          spikyBall.body.setCircle(19)
          spikyBall.body.setOffset(1, 1)
          group.add(spikyBall)
        }

        addEnemy(group, data) {
          const { x, y, dir = 1, type = 1, jumps = 1 } = data
          let enemy

          if (type === 2) {
            enemy = this.add.sprite(x, y, 'enemy2').setOrigin(0)
            enemy.setData('jumpCount', 0)
          } else {
            enemy = this.add.rectangle(x, y, 40, 40, 0xff004d).setOrigin(0)
          }

          enemy.setData('dir', dir)
          enemy.setData('type', type)

          this.physics.add.existing(enemy)
          if (type === 2) {
            enemy.body.setCircle(enemy.displayWidth / 3)
            enemy.body.setOffset(enemy.displayWidth / 6, enemy.displayWidth / 3)
            this.time.addEvent({
              callbackScope: this,
              delay: ENEMY2_JUMP_DELAY,
              loop: true,
              callback: () => {
                let jumpCount = enemy.getData('jumpCount') + 1
                let dir = enemy.getData('dir')
                if (jumpCount > jumps) {
                  dir *= -1
                  jumpCount = 1
                }
                enemy.body.setVelocity(123 * dir, -520)
                enemy.setData('jumpCount', jumpCount)
                enemy.setData('dir', dir)
              },
            })
          }

          this.enemies.add(enemy)
        }

        addTransformer(group, data) {
          const { x, y, width = 10, height = 10, mode = PLAYER_MODE_PLATFORM } = data
          const isHorizontal = height === 10

          this.add.particles(x, y, 'particleTransformer', {
            speed: { min: -20, max: 20 },
            scale: { min: 0.6, max: 1 },
            alpha: { start: 1, end: 0 },
            lifespan: 1000,
            frequency: 100,
            quantity: 5,
            emitZone: {
              source: new Phaser.Geom.Rectangle(0, 0, width, height),
              type: 'random',
            },
          })
          this.add.rectangle(x, y, width, height, 0x83769c).setOrigin(0)

          const hitboxWidth = isHorizontal ? width : 1
          const hitboxHeight = isHorizontal ? 1 : height
          const hitboxBeforeX = isHorizontal ? x : x + TILE_SIZE / 2 + width
          const hitboxBeforeY = isHorizontal ? y - TILE_SIZE / 2 : y
          const hitboxBefore = this.add
            .rectangle(hitboxBeforeX, hitboxBeforeY, hitboxWidth, hitboxHeight, 0x83769c, 0)
            .setOrigin(0)
          hitboxBefore.setData('mode', mode)
          group.add(hitboxBefore)

          const hitboxAfterX = isHorizontal ? x : x - TILE_SIZE / 2
          const hitboxAfterY = isHorizontal ? y + TILE_SIZE / 2 + height : y
          const hitboxAfter = this.add
            .rectangle(hitboxAfterX, hitboxAfterY, hitboxWidth, hitboxHeight, 0x83769c, 0)
            .setOrigin(0)
          hitboxAfter.setData('mode', mode === PLAYER_MODE_PLATFORM ? PLAYER_MODE_FLAPPY : PLAYER_MODE_PLATFORM)
          group.add(hitboxAfter)
        }

        addFallingBlock(group, triggerGroup, data) {
          const { x, y, num = 1 } = data
          for (let i = 0; i < num; i++) {
            const fallingBlock = this.add.rectangle(x + TILE_SIZE * i + 1, y, 38, 38, 0x5f574f)
            fallingBlock.setOrigin(0)
            group.add(fallingBlock)
            const trigger = this.add.rectangle(x + TILE_SIZE * i, y - 1, 40, 42)
            trigger.setOrigin(0)
            trigger.setData('block', fallingBlock)
            triggerGroup.add(trigger)
          }
        }

        handleFallingBlockCollision(player, fallingBlockTrigger) {
          const fallingBlock = fallingBlockTrigger.getData('block')
          if (!player.body.blocked.down || fallingBlockTrigger.getData('isTriggered')) return
          fallingBlockTrigger.setData('isTriggered', true)

          this.tweens.add({
            targets: fallingBlock,
            duration: 80,
            repeat: 4,
            yoyo: true,
            ease: 'Bounce.easeInOut',
            x: fallingBlock.x + 2,
            onComplete: () => {
              fallingBlock.body.enable = false
              this.tweens.add({
                targets: fallingBlock,
                y: fallingBlock.y + 40,
                alpha: 0,
                duration: 300,
                onComplete: () => {
                  fallingBlock.destroy()
                },
              })
            },
          })
        }

        handleCoin(player, coin) {
          this.coinsEmitter.setPosition(coin.x, coin.y)
          this.coinsEmitter.explode(8)
          this.events.emit('collectCoin')
          coin.destroy()
        }

        handleEnemiesCollision(player, enemy) {
          if (this.player.getData('isDead') || enemy.getData('isDead')) return

          const dx = player.x - enemy.x - TILE_SIZE / 2
          const dy = player.y - enemy.y - TILE_SIZE / 2

          const angle = Math.atan2(dy, dx)
          const angleDeg = Phaser.Math.RadToDeg(angle)
          if (angleDeg <= -45 && angleDeg >= -135 && enemy.getData('type') === 1) {
            enemy.setData('isDead', true)
            enemy.body.setVelocityX(0)

            this.tweens.add({
              targets: enemy,
              duration: 300,
              scale: 0,
              ease: 'Back.In',
              onComplete: () => {
                enemy.destroy()
              },
            })

            player.body.setVelocityY(-PLAYER_BOUNCE_OFF_VELOCITY)
            this.jumpCount = 1
            this.isJumping = true
            this.jumpStartTime = this.time.now
            this.isUpKeyPressed = false
            this.playerWasStanding = true

            return
          }

          this.die.call(this)
        }

        completePlayerTweens() {
          this.tweens.killTweensOf(this.playerSprite)
          this.playerSprite.setScale(1)
          this.playerSprite.angle = 0
          this.playerSprite.y = 0
        }

        handleCheckpoint() {
          if (this.isCheckpointActive || this.player.getData('isDead')) return
          this.isCheckpointActive = true
          this.checkpointTrigger.active = false
          this.registry.set('isCheckpointActive', true)

          this.tweens.add({
            targets: this.checkpointFlag,
            y: this.checkpointFlag.y - 60,
            duration: 1000,
            ease: 'Cubic.Out',
          })
        }

        handleTransformerCheck(player, transformer) {
          if (this.playerMode === transformer.getData('mode')) return

          this.playerMode = this.playerMode === PLAYER_MODE_PLATFORM ? PLAYER_MODE_FLAPPY : PLAYER_MODE_PLATFORM
          if (this.playerMode === PLAYER_MODE_FLAPPY) {
            this.jumpCount = 1
          } else {
            this.tweens.add({
              targets: this.playerSprite,
              angle: 0,
              duration: 200,
              ease: 'Cubic.easeOut',
            })
          }
        }

        handleMovingPlatforms(time, delta) {
          // Reset du stick plateforme
          this.stickedPlatform = this.player.getData('stickedPlatform')
          this.stickedVelocityX = 0
          if (this.stickedPlatform && !this.player.body.touching.down) {
            this.stickedPlatform = null
            this.player.setData('stickedPlatform', null)
          }

          this.oneWayPlatforms
            .getChildren()
            .filter((platform) => platform.getData('isMoving'))
            .forEach((platform) => {
              const previousX = platform.x
              const follower = platform.getData('follower')
              follower.path.getPoint(follower.t, follower.vec)
              const deltaX = follower.vec.x - platform.x
              const deltaY = follower.vec.y - platform.y
              platform.setPosition(follower.vec.x, follower.vec.y)
              follower.t += delta / 5000
              if (follower.t >= 1) {
                follower.t = 0
              }

              // Déplacement du joueur avec la plateforme
              if (this.stickedPlatform === platform) {
                this.player.y += deltaY
                this.stickedVelocityX = (platform.x - previousX) / (delta / 1000)
                if (this.player.body.velocity.x === 0) {
                  this.player.x += deltaX

                  // Détection à la main des collisions
                  if (
                    this.player.x - this.player.body.halfWidth < this.stickedPlatform.x ||
                    this.player.x + this.player.body.halfWidth > this.stickedPlatform.x
                  ) {
                    const x =
                      this.stickedVelocityX > 0
                        ? this.player.x + this.player.body.halfWidth
                        : this.player.x - this.player.body.halfWidth - 10
                    const rectDetection = new Phaser.Geom.Rectangle(x, this.player.y, 10, this.player.body.halfHeight)
                    const collidingPlatforms = this.platforms
                      .getChildren()
                      .filter((platform) =>
                        Phaser.Geom.Intersects.RectangleToRectangle(rectDetection, platform.getBounds())
                      )

                    if (collidingPlatforms.length) {
                      const platformToCheck = collidingPlatforms[0]
                      if (this.stickedVelocityX > 0 && this.player.x + this.player.body.halfWidth > platformToCheck.x) {
                        this.player.x = platformToCheck.x - this.player.body.halfWidth
                      } else if (
                        this.stickedVelocityX < 0 &&
                        this.player.x - this.player.body.halfWidth < platformToCheck.x + platformToCheck.width
                      ) {
                        this.player.x = platformToCheck.x + platformToCheck.width + this.player.body.halfWidth
                      }
                    }
                  }
                }
              }
            })
        }
      }

      const config = {
        type: Phaser.AUTO,
        backgroundColor: '#29ADFF',
        scale: {
          mode: Phaser.Scale.FIT,
          autoCenter: Phaser.Scale.CENTER_BOTH,
          width: 960,
          height: 540,
        },
        physics: {
          default: 'arcade',
          arcade: {
            gravity: {
              y: 1600,
            },
          },
        },
        input: {
          activePointers: 3,
        },
        scene: [
          PreloaderScene,
          IntroScene,
          LevelsScene,
          GameScene,
          HUDScene,
          TransitionScene,
          SettingsScene,
        ],
      }

      const game = new Phaser.Game(config)
    </script>
  </body>
</html>